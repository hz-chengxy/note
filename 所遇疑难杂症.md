## hr
1、薪资构成是什么？如果每月发放的工资包含绩效，则是否会扣除一部分。
2、社保缴纳比例？是按全额工资缴纳还是另有额度，是额度的5%还是12%(5% ~ 12%)
3、涨薪制度，是否是一年内不涨薪，一年后才开始考核
4、年终奖的发放形式
5、是否有补贴，发放形式
6、试用期间工资发放的比例，试用期多久
7、电脑和吃饭问题
8、入职需要准备什么东西，上班时间。
9、办公地点是否稳定，是否需要经常出差
10、北京的社保、公积金能转入杭州吗


## vue 路由跳转，新开页面
业务情景：由列表点击标题进入详情页，回退回来表单内容消失了不太友好，则需要记录并填充表单，觉得麻烦不如直接新打开一个标签。

在vue中$route.push跳转页面默认是在当前页面跳转路由，如果想新开一个页面，需要resolve。写法如下
```js
let text= this.$router.resolve({
      path: '/Started',
      query:{
        id:1
      }
    });
window.open(text.href, '_blank')
```
但是这种写法如果是在本地是没有问题的，一旦部署到线上(可能是因为添加了url的前缀)，在新开一个页面的时候，在打开页面由于各种原因变慢(可能是因为网速)，导致页面会重定向至根目录。
目前这个问题依然没有解决，只能去记录表单。

## 清除多个定时器
清除多个定时器：弄清楚一件事，用一个变量去接定时器，这个变量根本上会变成一个数值，而且一般这个数值是小于9999的，所以如果想要一股脑清掉所有的定时器，可以设置一个for循环，小于9999次，全部清掉。但是慎用，倒不是不能用，考虑清除清理范围就好。

如果一个组件中有多个定时器，而有几个定时器是通过循环产生的，需要只清除这几个循环产生的定时器，则可以：
```timer = setInterval(()=>{})``` 这个是要保存的定时器， 
```js
for(i=0;i<=7;i++){
  clearTimer = setInterval(()=>{})
}
```
这些是要清除的定时器

直接 
```js
for(i=timer+1;i<=clearTimer;i++){
  clearInterval(i)
}
``` 
看似clearTimer去接不同的定时器会被覆盖，实则是js用不同的数字去接受这些定时器，所有在清除时直接拿对应的数字清除即可。


## 富文本渲染dom时出现的问题
在用v-html渲染后端返回的富文本时，有时由于单引号'或者双引号"的问题，或者某些符号的问题，导致渲染出来的dom结构可能出现问题(具体问题看正则表达式业务实践二)
```js
str = str.replace(/<img\s*src=\"([^\"]*?)\"[^>]*>/gi,(match,capture) => {
    return "<img src='"+capture+"'>"
})
注：用括号括起来的是群组，用了群组后，match就是匹配到的字符串，后面的每个参数就是对应群组里的内容
```
其实就是把源字符串的img标签替换为空后再手动写入一个一样的img标签，那样就不会有图片显示不出来的问题。

## 利用axios终止多次请求
实际的业务需求：当接口访问速度非常慢时，而参数的变化非常快，且每次参数变化时都会请求接口，导致如果有一次较早发起的请求，其返回数据的速度比，较晚发起的请求，返回数据的速度慢，则会导致当前页实际要展示的数据被老数据覆盖。
解决方案：axios终止多次请求，解决的思路就在于，当你在不断发起异步请求的时候，如果说后面的请求有了响应前面的还在pending我就终止之前的请求，这样就很好的解决了这个问题。
示例，在vue中：
```js
mounted(){
    this.$watch("params",() => {
        this.cancelReq();  //取消请求 
        this.axios.get("url",{
            params:params,
            cancelToken: new this.axios.CancelToken((c) => {
                this.source = c;
            })
        })
    })
},
methods:{
    cancelReq() {
        if (typeof this.source === 'function') {
            this.source("取消请求");
        }
    },
}
```

## vue2底层的原因导致视图不更新
在vue中通过watch监听数据的变化，从而，该改变视图的时候，如果监听的数据是数组或对象，而且此时视图未更新，
数组：vm.items[1] = 'x' // 不是响应性的，可以改为 vm.items.splice(indexOfItem, 1, newValue)，即利用splice改变数组
对象：this.obj.message = 'hello' // 不是响应式的，可以改为 this.obj = Object.assign({}, this.obj, { a: 1, b: 2 })
当然，也可以暴力刷新：this.clearTagData[0]=this.checkedColumn[0];  this.$forceUpdate()

参考博客：https://segmentfault.com/a/1190000022772025

## vue中无法监测hashChange
由于vue底层调用的是history.pushState和history.replaceState,当url中#后的地址发生变化时并不会触发hashchange事件。所以必须要调用路由守卫。
但是如果vue需要引入外部js，外部的js中无法调用vue的API。

例如一个实际的业务：所做的经济日报大屏：https://m.jjrbs.cn/bigscreen
首页的设计图要比其他页面的宽，高一致，那么导致这俩页面的缩放比例不一样，所以我需要根据路由的不同来决定缩放比例，而在外部引入的js中，监测不到路由的变化，即触发不了onhashChange，且也不知道如何在js中写路由守卫，所以只能将js中的函数导出到vue中，在App.vue中写路由守卫，监测路由变化，从而决定执行哪个缩放逻辑。

在App.vue写路由守卫
```js
import {resizeHome,resizeSmall,resizeTest} from '@/assets/js/resizes.js'
this.$router.beforeEach((to, from, next) => {
  // resizeHome()
  // resizeSmall()
  if(to.name == "Main"){
    resizeHome()
  }else{
    resizeSmall()
  }
  next();
});
```

## vue3在项目中遇到的监听reactive的问题 (reactive数据类型不要改变其地址，否则监听不到变化)
在watch监听reactive数据的变化时，直接改变reactive属性的地址时，比如reactive.arr = [],如此操作后数据的地址发生变化，导致watch即使加上了deep属性，也获取不到变化，需要reactive.arr.length = 0等不改变对象数组地址的方法来改变数据，才能让watch监听到

## 翻译api
详细看vue相关

## 前端解析加密视频格式，类似抖音
在头部加入以下即可,这样类似抖音的加密视频都可以播放了，暂时是这样的，后续可能失效，因为抖音的加密策略可能会变化
https://aweme.snssdk.com/aweme/v1/playwm/?video_id=v0200fg10000cb216kbc77u2mb836180&ratio=360p&line=0
https://aweme.snssdk.com/aweme/v1/playwm/?video_id=v0300fg10000c581h43c77u54a0h6uu0&ratio=720p&line=0
```html
<meta name="referrer" content="never"></meta>
```

## 统计系统关联页面(应该是目前最复杂的页面)
关联的业务逻辑是由前端完成的，表格最上方的当前关联也是前端拼接上去的。所以我的调接口时机只能是在点击确认时，以下所有逻辑都在确认的回调中。
难点：
1、什么情景补第一行的已关联。
2、不同情景进入关联页表格第一列的序号展示情况不同。(不补第一行是正常1开始，补得话第一行是已关联或未关联)。
3、取消关联和关联的判断，从外面选择稿件，多选和单选的区别。

整体逻辑：
首先判断是通过什么途径进来页面的：
如果是通过图标进来的，则说明原来必已关联两种情况：
1、点击确定时无关联稿件，则相当于做了取消关联的操作。
2、有关联稿件，若为第一个，则相当于什么操作都没有做，若不是第一个：还需再判断是否与取消关联的稿件id一致，如果一致，警告一下，什么都不做。如果不一致，则先取消关联，再关联。
如果是通过点击按钮进来的，
1、如果是单选，判断其关联情况，若为未关联：点击按钮时若无关联稿件，相当于什么都没做。若有关联稿件，则相当于直接关联。若为已关联，和点击按钮进来的判断逻辑一致。
2、如果是多选，若关联的稿件是一篇稿件，则也和点击按钮进来的判断逻辑一致。如果不是，统一按照未关联的页面处理：若点击按钮时没有已关联的稿件，则相当于做了取消关联的操作，若有关联的稿件，则统一都取消关联再关联该篇稿件(如果可以判断下多选的稿件是否存在已关联的情况在做逻辑选择更好。)

## 见原生js相关：排序的业务逻辑复杂，需要添加多种逻辑写法

## 见原生js相关：利用storage事件传参

## 见原生js相关：动态的富文本生成的dom添加点击事件

## 见echarts相关：echarts分辨率变化后鼠标移入焦点错位

## 见vue相关：切换路由后，页面接口异常刷新。（集中在mounted, created的接口）