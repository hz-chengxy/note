## 常用正则
* 1~30个字符，必须包含字母 : ```/^(?=.*[A-Za-z])[A-Za-z\d`~!@#$%^&*()_\-+=<>?:"{}|,./;'\\[\]~！@#￥%……&*（）——\-+={}|《》？：“”【】、；‘'，。、]{1,30}$/```
* 密码，不包含特殊字符  `/^(?=\D+\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,16}$/`
* 密码，包含特殊字符  `/^(?=\D+\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W).{8,16}$/`

* 字符串去重  `/(\w)\1*/g`

* 密码，不能以数字开头，但必须包含数字、cxy、大写字母、8-16  `/^(?=\D+\d)(?=.*cxy)(?=.*[A-Z])[a-zA-Z0-9]{8,16}$/`

* 文件名由字母、数字、下划线构成，不可以以数字、下划线开头，后缀为.zip/rar/gz  `/^(?=\D)(?!_)\w+\.(zip|rar|gz)$/g`

* 年龄，18-100 `/^(1[8-9]|[2-9]\d|100)$/`

* 15或18位，如果是15位则全部为数字，如果为18位，前17位为数字，第18位为数字或字母x，字母不区分大小写  `/(\d{15}|\d{17}[\dx])/i`

* 三个汉字、中间必须是小或晓  `/[\u4e00-\u9fa5][小晓][\u4e00-\u9fa5]/`

* 给定任何一串数字将其转换为科学计数法(10000 => 10,000)
先看上边这个，从后往前匹配，紧随其后的需是3个或6、9、等3的倍数个数字，但这样如果刚好有3的倍数位，头部也会匹配
let reg7 = /(?=(\d{3})+$)/g
为了避免上述问题，加了个\B 匹配非单词边界（界左界右为同类），由于第一位前面的界左是空，右是字符，左右异类，所以被排除
`/(?=(\B)(\d{3})+$)/g`

* 匹配图片  `/<img[^>]+src=["']([^'"]+)["'].*?>/g`

## 创建正则
使用对象创建正则表达式时可以使用变量
```js
let a = '@'
let reg = new RegExp(a,'g') //后面表示匹配模式
```
且在对象的写法中\d、\w、\s、\\.、等前面都需要再加转义符\,也就是说，所有的元字符和在正则中需要转义的内容都需要多加一个转义符。
原因是字符串会将\d识别为d，所以需要告诉字符串，将他识别为转义符。如果对象型写法正则识别不出来，则可以打印这个正则里的字符串内容，检查它是否和期望的正则一样，有时正是因为少个\（转义符）而导致的匹配不到

### 常见的需要转义的字符串
\  /  .

### \w 与\W
\w 是数字，字母，下划线，包括下划线。
\W 是除了这些，也就是特殊字符
.  是除了换行符以外的所有内容
`[\d\D]` 则表示所有字符，用\S\s也是同样的道理

### 三种匹配模式
i 忽略大小写
g 全局匹配
s 视为单行匹配，将换行符视为普通的空格匹配
m 将多行内容视为多行匹配（多行内容的每一行单独处理，每一行视为一个匹配单元，每一行单独对待），常有^、$开始结束符，如需要匹配的原内容是多行的，
```js
let hd = `
#1 js,200 #
#2 php,300 #
#3 express,400 # 拓尔思
#4 node,500 #
`
```
贪婪匹配，将这四行通过一个正则匹配出来，可当做四个单独的匹配单元，则用m匹配模式。

## 展开表达式
```js
let str = "houdunren2200fff9988"
    console.log(...str)//字符串每项中间
    console.log([...str])//将字符串的每一项都当做数组的每一项
```

## Number.NaN
Number.isNaN() 检查值是否为NaN值

## 正则业务实践
### 一
如果需要在正则验证中添加变量，则需要将正则表达式单独写出来
规则：需要将非正则中使用的符号全部用"\"转义
例如：就是正则验证中添加了videoId变量，去筛选不同videoid的img标签
`let re = new RegExp('<img[^\>]*?videoid=[\'\"]' + self.videoId + '[\'\"][^\>]*>', 'ig')`

解析正则：img和videoid属性之间可能存在任何字符串，除了>右括号，所以[^\>]*?，之后是videoid，和可能出现的两种引号"',引号之间是videoId，在videoid属性之后还可能存在其他属性，但还是不能出现>右括号，所以再加上一组[^\>],最后加上ig全局匹配和忽略大小写。

在确立的正则验证后，在后续的表达式中就可以直接应用。
str.replace(re,function(match,capture1,capture2){
    console.log(match)  //匹配的整体
    console.log(capture1)  //第一个子表达式
    console.log(capture2)  //第二个子表达式
})

### 二
<img src="./dom_err.png" alt="">
在用v-html渲染后端返回的富文本时，有时由于单引号'或者双引号"的问题，或者某些符号的问题，导致渲染出来的dom结构可能出现问题，比如`<img src="fasfa"><p>fadsfa</p></img>`这个dom结构会使图片无法正常显示，而正文的p标签没啥问题。最终解决方案：
```js
str = str.replace(/<img\s*src=\"([^\"]*?)\"[^>]*>/gi,(match,capture) => {
    return "<img src='"+capture+"'>"
})
注：用括号括起来的是群组，用了群组后，match就是匹配到的字符串，后面的每个参数就是对应群组里的内容
```
其实就是把源字符串的img标签替换为空后再手动写入一个一样的img标签，那样就不会有图片显示不出来的问题。

### 三：匹配图片以及其src的正则表达式
`/<img[^>]+src=['"]([^'"]+)['"]+/g,`
`/<img\s*src=\"([^\"]*?)\"[^>]*>/gi`
若想拿到src，则可以向上面踩坑写法一样，用replace配合群组获取。
或者excu方法，但是该方法不能全局匹配
```js
let patt = /<img[^>]+src=['"]([^'"]+)['"]+/g
let arr = patt.exec(detailDataMsg.item.XQCONTENT)
得到的这个数组第一项是匹配到的字符串，第二项是群组里的内容
```

